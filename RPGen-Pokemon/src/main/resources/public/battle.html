<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combate Pokémon</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode {
            background-color: #1a1a1a;
            color: #ffffff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .battle-arena {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .team-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode .team-section {
            background: #2d2d2d;
            color: #ffffff;
        }

        .active-pokemon {
            text-align: center;
            margin-bottom: 20px;
        }

        .active-pokemon img {
            width: 200px;
            height: 200px;
            object-fit: contain;
        }

        .pokemon-stats {
            margin-top: 10px;
        }

        .health-bar {
            background-color: #ddd;
            width: 100%;
            height: 20px;
            border-radius: 10px;
            margin: 5px 0;
        }

        .health-bar-fill {
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease-in-out;
        }

        .team-pokemon {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 20px;
        }

        .pokemon-card {
            background: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            text-align: center;
            position: relative;
            transition: transform 0.2s, opacity 0.2s, background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        .pokemon-card.active {
            border-color: #4CAF50;
            background-color: #e8f5e9;
        }

        .pokemon-card img {
            width: 80px;
            height: 80px;
            object-fit: contain;
        }

        .moves-section {
            margin-top: 20px;
        }

        .moves-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .move-button {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .move-button:hover {
            background-color: #45a049;
        }

        .move-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .cancel-button {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background-color: #f44336;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .cancel-button:hover {
            background-color: #da190b;
        }

        .battle-log {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-height: 600px;
            overflow-y: auto;
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode .battle-log {
            background: #2d2d2d;
            color: #ffffff;
        }

        .battle-log p {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }

        .type-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            color: white;
            text-transform: capitalize;
            margin: 0 2px;
        }

        /* Colores de tipos */
        .type-normal { background-color: #A8A878; }
        .type-fire { background-color: #F08030; }
        .type-water { background-color: #6890F0; }
        .type-electric { background-color: #F8D030; }
        .type-grass { background-color: #78C850; }
        .type-ice { background-color: #98D8D8; }
        .type-fighting { background-color: #C03028; }
        .type-poison { background-color: #A040A0; }
        .type-ground { background-color: #E0C068; }
        .type-flying { background-color: #A890F0; }
        .type-psychic { background-color: #F85888; }
        .type-bug { background-color: #A8B820; }
        .type-rock { background-color: #B8A038; }
        .type-ghost { background-color: #705898; }
        .type-dragon { background-color: #7038F8; }
        .type-dark { background-color: #705848; }
        .type-steel { background-color: #B8B8D0; }
        .type-fairy { background-color: #EE99AC; }

        .team-selector {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .team-selector select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background: linear-gradient(90deg, #43e97b 0%, #38f9d7 100%);
            color: #222;
            font-weight: bold;
            box-shadow: 0 2px 8px #0003;
            transition: background 0.2s, transform 0.1s;
        }
        .team-selector select option {
            background: #fff;
            color: #222;
        }
        body.dark-mode .team-selector select {
            background: linear-gradient(90deg, #232b23 0%, #38f9d7 100%);
            color: #fff;
            border-color: #555;
        }
        body.dark-mode .team-selector select option {
            background: #232b23;
            color: #fff;
        }

        .main-battle-btn {
            font-size: 1.2em;
            padding: 0.9em 2.2em;
            border-radius: 12px;
            background: linear-gradient(90deg, #43e97b 0%, #38f9d7 100%);
            color: #222;
            font-weight: bold;
            border: none;
            margin: 0 0.5em;
            box-shadow: 0 2px 8px #0003;
            transition: background 0.2s, transform 0.1s;
            cursor: pointer;
        }
        .main-battle-btn:hover {
            background: linear-gradient(90deg, #38f9d7 0%, #43e97b 100%);
            transform: scale(1.05);
        }
        body.dark-mode .main-battle-btn {
            background: linear-gradient(90deg, #232b23 0%, #38f9d7 100%);
            color: #fff;
        }

        .pokemon-stats-tooltip {
            display: none;
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            min-width: 200px;
            text-align: left;
        }

        .pokemon-card:hover .pokemon-stats-tooltip {
            display: block;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 14px;
        }

        .stat-label {
            font-weight: bold;
            color: #666;
        }

        .stat-value {
            color: #333;
        }

        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }

        .attacking {
            animation: attack 1s ease-in-out;
        }
        
        .taking-damage {
            animation: take-damage 0.5s ease-in-out;
        }
        
        .move-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1.2em;
            z-index: 1000;
        }
        
        @keyframes attack {
            0% { transform: translateX(0); }
            25% { transform: translateX(50px); }
            50% { transform: translateX(0); }
            100% { transform: translateX(0); }
        }
        
        @keyframes take-damage {
            0% { transform: translateX(0); }
            25% { transform: translateX(-20px); }
            50% { transform: translateX(20px); }
            75% { transform: translateX(-10px); }
            100% { transform: translateX(0); }
        }

        .pokemon-card.fainted {
            opacity: 0.5;
            filter: grayscale(100%);
            cursor: not-allowed;
        }
        .pokemon-card.fainted:hover {
            transform: none;
        }

        @keyframes attack {
            0% { transform: translateX(0); }
            25% { transform: translateX(50px); }
            50% { transform: translateX(0); }
            100% { transform: translateX(0); }
        }

        @keyframes hit {
            0% { transform: translateX(0); }
            25% { transform: translateX(-20px); }
            50% { transform: translateX(0); }
            100% { transform: translateX(0); }
        }

        .move-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1.2em;
            z-index: 1000;
        }

        @keyframes switchOut {
            0% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(-50px); }
        }

        @keyframes switchIn {
            0% { opacity: 0; transform: translateX(50px); }
            100% { opacity: 1; transform: translateX(0); }
        }

        body.dark-mode .pokemon-card {
            background: #232323;
            color: #e0e0e0;
            border-color: #444;
        }
        body.dark-mode .pokemon-card.active {
            background: #294d29;
            border-color: #6fcf97;
        }
        body.dark-mode .pokemon-card.fainted {
            background: #232323;
            color: #888;
            border-color: #333;
        }
        body.dark-mode .pokemon-card:hover {
            background: #333;
        }

        /* Estilos para la animación del ganador */
        .winner-announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background-color: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
            opacity: 0;
            transition: all 0.5s ease-out;
        }

        .winner-announcement.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .winner-announcement h2 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            color: #4CAF50;
        }

        .winner-announcement p {
            font-size: 1.5rem;
            margin: 0;
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background-color: #f00;
            opacity: 0;
            z-index: 999;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        body.dark-mode .selected-move-item .move-power {
            background: #232323;
            color: #b0e0ff;
        }

        .config-info {
            font-size: 12px;
            margin-top: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.05);
            border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode .config-info {
            background: rgba(255,255,255,0.1);
            color: #f0f0f0;
        }

        .main-header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: #222;
            color: #fff;
            z-index: 10000;
            box-shadow: 0 2px 8px #0002;
        }
        .main-header nav {
            display: flex;
            justify-content: center;
            gap: 2em;
            padding: 1em 0;
        }
        .main-header a, .main-header .theme-toggle {
            color: #fff;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1em;
            transition: color 0.2s, background 0.2s;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0 0.5em;
            height: 100%;
            display: flex;
            align-items: center;
        }
        .main-header a:hover, .main-header .theme-toggle:hover {
            color: #4CAF50;
            background: none;
        }
        body.dark-mode .main-header a, body.dark-mode .main-header .theme-toggle {
            color: #f0f0f0;
        }
        body.dark-mode .main-header a:hover, body.dark-mode .main-header .theme-toggle:hover {
            color: #6fcf97;
        }
        body {
            padding-top: 70px !important;
        }
        body.dark-mode .main-header {
            background: #181818;
            color: #f0f0f0;
        }
        body.dark-mode .main-header a {
            color: #f0f0f0;
        }
        body.dark-mode .main-header a:hover {
            color: #6fcf97;
        }
    </style>
</head>
<body>
    <header class="main-header">
        <nav>
            <a href="index.html">Inicio</a>
            <a href="pokemon.html">Pokédex</a>
            <a href="battle.html">Combate Pokémon</a>
            <a href="chrono-team.html">Selección de Equipos Chrono</a>
            <a href="chrono-battle.html">Combate Chrono Trigger</a>
            <button class="theme-toggle" onclick="toggleDarkMode()">Cambiar Tema</button>
        </nav>
    </header>
    <div class="container">
        <!-- Añadir el div para el anuncio del ganador -->
        <div id="winnerAnnouncement" class="winner-announcement">
            <h2>¡Batalla Finalizada!</h2>
            <p id="winnerText"></p>
        </div>
        <div class="team-selector">
            <select id="team1Selector">
                <option value="">Selecciona Equipo 1</option>
            </select>
            <select id="team2Selector">
                <option value="">Selecciona Equipo 2</option>
            </select>
            <button class="main-battle-btn" onclick="startBattle()">Iniciar Batalla</button>
            <button id="resetBattle" class="main-battle-btn" onclick="resetBattle()">Resetear Batalla</button>
        </div>
        <div class="battle-arena">
            <div class="team-section">
                <h2>Equipo 1</h2>
                <div class="active-pokemon">
                    <img id="team1ActivePokemon" src="" alt="Pokémon activo">
                    <div class="pokemon-stats">
                        <h3 id="team1PokemonName"></h3>
                        <div class="health-bar">
                            <div id="team1HealthBar" class="health-bar-fill" style="width: 100%; background-color: #4CAF50;"></div>
                        </div>
                        <p id="team1Health"></p>
                    </div>
                </div>
                <div class="moves-section">
                    <h3>Movimientos</h3>
                    <div id="team1Moves" class="moves-grid"></div>
                </div>
                <div class="team-pokemon" id="team1Pokemon"></div>
            </div>
            <div class="team-section">
                <h2>Equipo 2</h2>
                <div class="active-pokemon">
                    <img id="team2ActivePokemon" src="" alt="Pokémon activo">
                    <div class="pokemon-stats">
                        <h3 id="team2PokemonName"></h3>
                        <div class="health-bar">
                            <div id="team2HealthBar" class="health-bar-fill" style="width: 100%; background-color: #4CAF50;"></div>
                        </div>
                        <p id="team2Health"></p>
                    </div>
                </div>
                <div class="moves-section">
                    <h3>Movimientos</h3>
                    <div id="team2Moves" class="moves-grid"></div>
                </div>
                <div class="team-pokemon" id="team2Pokemon"></div>
            </div>
            <div class="battle-log" id="battleLog">
                <p>Esperando inicio de batalla...</p>
            </div>
        </div>
    </div>

    <script>
        let allTeams = {};
        let currentBattleId = null;
        let selectedTeam1 = null;
        let selectedTeam2 = null;
        let activePokemon1 = null;
        let activePokemon2 = null;
        let battleLog = [];
        let selectedMove1 = null;
        let selectedMove2 = null;
        let turnInProgress = false;
        let lastAction1 = null;
        let lastAction2 = null;
        let waitingForTeam1 = true;
        let waitingForTeam2 = true;
        let animationInProgress = false;
        let battleOver = false;
        const ATTACK_ANIMATION_DURATION = 1000; // Duración de la animación en milisegundos
        let initialSelectionPending = true; // Definición inicial de la bandera
        let actionSelected1 = false;  // Nueva variable para controlar si el equipo 1 ha seleccionado una acción
        let actionSelected2 = false;  // Nueva variable para controlar si el equipo 2 ha seleccionado una acción
        let currentTurn = 0; // Contador de turnos actual
        
        // Variables para restricción de movimientos Choice
        let lockedMoveTeam1 = null;
        let lockedMoveTeam2 = null;

        // API para comunicación con el backend
        const api = {
            async startBattle(team1, team2) {
                const response = await fetch('/api/pokemon-battle/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ team1, team2 })
                });
                if (!response.ok) {
                    throw new Error('Error al iniciar la batalla');
                }
                return await response.json();
            },

            async performAction(battleId, source, target, action) {
                if (!battleId) {
                    throw new Error('No hay una batalla activa');
                }
                const response = await fetch(`/api/pokemon-battle/${battleId}/action`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ source, target, action })
                });
                if (!response.ok) {
                    throw new Error('Error al realizar la acción');
                }
                return await response.json();
            },

            async calculateTypeEffectiveness(data) {
                try {
                    const response = await fetch('/api/pokemon-battle/type-effectiveness', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            attackType: data.attackType,
                            defenderTypes: data.defenderTypes
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Error al calcular la efectividad de tipos');
                    }

                    const result = await response.json();
                    return result.effectiveness;
                } catch (error) {
                    console.error('Error en calculateTypeEffectiveness:', error);
                    throw error;
                }
            },

            async switchPokemon(battleId, newPokemon, isTeam1) {
                if (!battleId) {
                    throw new Error('No hay una batalla activa');
                }
                const response = await fetch(`/api/pokemon-battle/${battleId}/switch`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ newPokemon, isTeam1 })
                });
                if (!response.ok) {
                    throw new Error('Error al cambiar de Pokémon');
                }
                return await response.json();
            },

            async processTurn(battleId) {
                if (!battleId) {
                    throw new Error('No hay una batalla activa');
                }
                const response = await fetch(`/api/pokemon-battle/${battleId}/process-turn`, {
                    method: 'POST'
                });
                if (!response.ok) {
                    throw new Error('Error al procesar el turno');
                }
                return await response.json();
            }
        };

        // Función para habilitar/deshabilitar botones de movimientos y cambios
        function setMoveAndSwitchButtonsEnabled(enabled, teamId = null) {
            // Deshabilitar todos los botones si el turno está en progreso o la batalla ha terminado
            const shouldDisable = !enabled || turnInProgress || battleOver;
            
            // Actualizar botones de movimientos
            const movesContainer = teamId ? 
                document.getElementById(`${teamId}Moves`) : 
                document.querySelectorAll('.moves-grid');
            
            if (teamId) {
                // Solo actualizar los botones del equipo especificado
                const buttons = movesContainer.querySelectorAll('.move-button');
                buttons.forEach(btn => {
                    btn.disabled = shouldDisable;
                });
            } else {
                // Actualizar todos los botones
                movesContainer.forEach(container => {
                    const buttons = container.querySelectorAll('.move-button');
                    buttons.forEach(btn => {
                        btn.disabled = shouldDisable;
                    });
                });
            }
            
            // Actualizar botones de cambio de Pokémon
            const cards = teamId ? 
                document.querySelectorAll(`[data-team="${teamId}"].pokemon-card`) :
                document.querySelectorAll('.pokemon-card');
            
            cards.forEach(card => {
                const pokemon = card.dataset.pokemonId;
                const team = card.dataset.team;
                
                // Solo habilitar si el Pokémon tiene HP > 0 y su equipo no ha seleccionado una acción
                const pokemonData = team === 'team1' ? 
                    selectedTeam1.find(p => p.uniqueId === pokemon) :
                    selectedTeam2.find(p => p.uniqueId === pokemon);
                
                const hasSelectedAction = team === 'team1' ? 
                    (selectedMove1 || lastAction1 === 'move') :
                    (selectedMove2 || lastAction2 === 'move');
                
                // Si el Pokémon está debilitado, deshabilitar la tarjeta
                if (pokemonData && pokemonData.health <= 0) {
                    card.style.pointerEvents = 'none';
                    card.style.opacity = '0.5';
                    card.classList.add('fainted');
                } else if (pokemonData && pokemonData.health > 0 && !hasSelectedAction) {
                    card.style.pointerEvents = shouldDisable ? 'none' : 'auto';
                    card.style.opacity = shouldDisable ? '0.5' : '1';
                    card.classList.remove('fainted');
                } else {
                    card.style.pointerEvents = 'none';
                    card.style.opacity = '0.5';
                }
            });
        }

        // Función para actualizar la barra de vida con animación
        function updateHealthBar(pokemon, newHealth) {
            // Determinar si es un Pokémon activo principal o una tarjeta pequeña
            let healthBarElement;
            let healthTextElement;
            let teamCardElement;

            // Comprobar si el Pokémon es el activo del equipo 1 o equipo 2 basándose en el uniqueId
            if (activePokemon1 && pokemon.uniqueId === activePokemon1.uniqueId) {
                healthBarElement = document.getElementById('team1HealthBar');
                healthTextElement = document.getElementById('team1Health');
                teamCardElement = document.querySelector(`[data-pokemon-id="${pokemon.uniqueId}"] .health-bar-fill`);
            } else if (activePokemon2 && pokemon.uniqueId === activePokemon2.uniqueId) {
                healthBarElement = document.getElementById('team2HealthBar');
                healthTextElement = document.getElementById('team2Health');
                teamCardElement = document.querySelector(`[data-pokemon-id="${pokemon.uniqueId}"] .health-bar-fill`);
            } else {
                // Es una tarjeta pequeña de Pokémon
                healthBarElement = document.querySelector(`[data-pokemon-id="${pokemon.uniqueId}"] .health-bar-fill`);
                healthTextElement = document.querySelector(`[data-pokemon-id="${pokemon.uniqueId}"] div:last-of-type`);
            }

            if (!healthBarElement) return;
            
            // Obtener el porcentaje de salud actual del elemento DOM
            const currentHealthPercentage = parseFloat(healthBarElement.style.width) || 0;
            const targetHealthPercentage = (newHealth / pokemon.maxHealth) * 100;
            const healthColor = targetHealthPercentage > 50 ? '#4CAF50' : targetHealthPercentage > 25 ? '#FFA500' : '#FF4444';
            
            // Animar la reducción de la barra de vida
            const duration = 500; // duración de la animación en ms
            const startTime = performance.now();
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const animatedWidth = currentHealthPercentage - (currentHealthPercentage - targetHealthPercentage) * progress;
                healthBarElement.style.width = `${animatedWidth}%`;
                healthBarElement.style.backgroundColor = healthColor;

                // Actualizar también la barra de vida en la tarjeta del equipo si existe
                if (teamCardElement) {
                    teamCardElement.style.width = `${animatedWidth}%`;
                    teamCardElement.style.backgroundColor = healthColor;
                }

                if (healthTextElement) {
                    // Para la animación del texto, es mejor interpolar entre la salud actual y la nueva salud
                    const currentDisplayedHealth = Math.round((currentHealthPercentage / 100) * pokemon.maxHealth);
                    const animatedHealth = Math.round(currentDisplayedHealth - (currentDisplayedHealth - newHealth) * progress);
                    healthTextElement.textContent = `HP: ${animatedHealth}/${pokemon.maxHealth}`;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Asegurarse de que el valor final sea exacto
                    healthBarElement.style.width = `${targetHealthPercentage}%`;
                    if (teamCardElement) {
                        teamCardElement.style.width = `${targetHealthPercentage}%`;
                    }
                    if (healthTextElement) {
                        healthTextElement.textContent = `HP: ${newHealth}/${pokemon.maxHealth}`;
                    }
                }
            }
            
            requestAnimationFrame(animate);
        }

        // Actualizar movimientos
        function updateMoves(teamId, pokemon) {
            const movesContainer = document.getElementById(`${teamId}Moves`);
            movesContainer.innerHTML = '';

            if (!pokemon || !pokemon.moves) {
                console.warn('No hay movimientos disponibles para', pokemon?.name);
                return;
            }

            // Obtener los movimientos seleccionados del Pokémon activo
            const selectedMoves = pokemon.selectedMoveIndices ? 
                pokemon.selectedMoveIndices.map(index => pokemon.moves[index]).filter(move => move) :
                [];

            // Si no hay movimientos seleccionados, no mostrar ninguno
            if (selectedMoves.length === 0) {
                console.warn('No hay movimientos seleccionados para', pokemon.name);
                return;
            }

            // Verificar si el Pokémon tiene un objeto Choice que restringe movimientos
            const hasChoiceItem = pokemon.heldItem && pokemon.heldItem.extraEffects && 
                                 pokemon.heldItem.extraEffects.onlyOneMove;
            
            // Obtener el movimiento bloqueado para este equipo
            const lockedMove = teamId === 'team1' ? lockedMoveTeam1 : lockedMoveTeam2;

            selectedMoves.forEach(move => {
                if (!move) {
                    console.warn('Movimiento nulo encontrado en', pokemon.name);
                    return;
                }
                
                const button = document.createElement('button');
                button.className = 'move-button';
                button.textContent = `${move.name} (${move.power})`;
                
                // Si tiene objeto Choice y ya hay un movimiento bloqueado, deshabilitar otros movimientos
                if (hasChoiceItem && lockedMove && lockedMove !== move.name) {
                    button.disabled = true;
                    button.style.opacity = '0.5';
                    button.title = 'Objeto Choice: Solo puedes usar ' + lockedMove;
                }
                
                button.addEventListener('click', () => selectMove(teamId, move));
                movesContainer.appendChild(button);
            });
        }

        // Actualizar lista de Pokémon del equipo
        function updateTeamPokemon(teamId, team) {
            const container = document.getElementById(`${teamId}Pokemon`);
            container.innerHTML = '';

            team.forEach(pokemon => {
                const card = document.createElement('div');
                card.className = 'pokemon-card';
                card.dataset.pokemonId = pokemon.uniqueId;
                card.dataset.team = teamId;
                
                // Añadir clase si es el Pokémon activo
                if ((teamId === 'team1' && activePokemon1 && activePokemon1.uniqueId === pokemon.uniqueId) ||
                    (teamId === 'team2' && activePokemon2 && activePokemon2.uniqueId === pokemon.uniqueId)) {
                    card.classList.add('active');
                }

                // Calcular el porcentaje de HP para la barra de vida
                const hpPercentage = (pokemon.health / pokemon.maxHealth) * 100;
                const healthColor = hpPercentage > 50 ? '#4CAF50' : hpPercentage > 25 ? '#FFA500' : '#FF4444';

                // Obtener información de configuración
                const nature = pokemon.nature ? pokemon.nature.name : 'Aleatoria';
                const heldItem = pokemon.heldItem ? pokemon.heldItem.name : 'Ninguno';
                const selectedAbility = pokemon.selectedAbility ? pokemon.selectedAbility.name : 'Ninguna';
                const level = pokemon.level || 50;

                card.innerHTML = `
                    <img src="${pokemon.imageUrl}" alt="${pokemon.name}">
                    <h3>${pokemon.name}</h3>
                    <div class="health-bar">
                        <div class="health-bar-fill" style="width: ${hpPercentage}%; background-color: ${healthColor};"></div>
                    </div>
                    <p>HP: ${pokemon.health}/${pokemon.maxHealth}</p>
                    
                    <!-- Información de configuración -->
                    <div style="font-size: 10px; margin-top: 5px; padding: 5px; background: rgba(0,0,0,0.1); border-radius: 3px;">
                        <div><strong>Lv.${level}</strong></div>
                        <div>${nature}</div>
                        <div>${heldItem}</div>
                        <div>${selectedAbility}</div>
                    </div>
                `;

                // Solo permitir seleccionar Pokémon con HP > 0
                if (pokemon.health > 0) {
                    card.addEventListener('click', () => switchPokemon(pokemon, teamId));
                }

                container.appendChild(card);
            });
        }

        // --- Funciones principales de la batalla ---

        // Seleccionar movimiento
        function selectMove(teamId, move) {
            if (turnInProgress || battleOver) return;

            const selectedMove = teamId === 'team1' ? selectedMove1 : selectedMove2;
            const lastAction = teamId === 'team1' ? lastAction1 : lastAction2;
            const activePokemon = teamId === 'team1' ? activePokemon1 : activePokemon2;

            if (selectedMove || lastAction === 'move') {
                updateBattleLog(`El ${teamId === 'team1' ? 'Equipo 1' : 'Equipo 2'} ya ha seleccionado un movimiento en este turno`);
                return;
            }

            // Verificar restricción de objeto Choice
            const hasChoiceItem = activePokemon && activePokemon.heldItem && 
                                 activePokemon.heldItem.extraEffects && 
                                 activePokemon.heldItem.extraEffects.onlyOneMove;
            
            const lockedMove = teamId === 'team1' ? lockedMoveTeam1 : lockedMoveTeam2;
            
            if (hasChoiceItem) {
                if (lockedMove === null) {
                    // Primer movimiento: bloquear
                    if (teamId === 'team1') {
                        lockedMoveTeam1 = move.name;
                    } else {
                        lockedMoveTeam2 = move.name;
                    }
                    updateBattleLog(`${activePokemon.name} ha usado ${move.name} por primera vez. Objeto Choice activado.`);
                } else if (lockedMove !== move.name) {
                    // Intento de cambiar movimiento: forzar el bloqueado
                    updateBattleLog(`${activePokemon.name} intenta cambiar de movimiento, pero el objeto Choice lo fuerza a usar ${lockedMove}.`);
                    
                    // Buscar el movimiento bloqueado en la lista de movimientos
                    const selectedMoves = activePokemon.selectedMoveIndices ? 
                        activePokemon.selectedMoveIndices.map(index => activePokemon.moves[index]).filter(m => m) :
                        [];
                    const forcedMove = selectedMoves.find(m => m.name === lockedMove);
                    
                    if (!forcedMove) {
                        updateBattleLog('Error: No se encontró el movimiento bloqueado');
                        return;
                    }
                    
                    move = forcedMove;
                }
            }

            if (teamId === 'team1') {
                selectedMove1 = move;
                lastAction1 = 'move';
                waitingForTeam1 = false;
            } else {
                selectedMove2 = move;
                lastAction2 = 'move';
                waitingForTeam2 = false;
            }

            // Desactivar solo los botones del equipo que seleccionó la acción
            setMoveAndSwitchButtonsEnabled(false, teamId);

            // Añadir botón de cancelar
            const movesContainer = document.getElementById(`${teamId}Moves`);
            const cancelButton = document.createElement('button');
            cancelButton.className = 'cancel-button';
            cancelButton.textContent = 'Cancelar ataque';
            cancelButton.onclick = () => {
                if (teamId === 'team1') {
                    selectedMove1 = null;
                    lastAction1 = null;
                    waitingForTeam1 = true;
                } else {
                    selectedMove2 = null;
                    lastAction2 = null;
                    waitingForTeam2 = true;
                }
                setMoveAndSwitchButtonsEnabled(true, teamId);
                cancelButton.remove();
            };
            movesContainer.appendChild(cancelButton);

            updateBattleLog(`${teamId === 'team1' ? 'Equipo 1' : 'Equipo 2'} ha seleccionado un ataque` /*${move.name}*/);

            if (!waitingForTeam1 && !waitingForTeam2) {
                turnInProgress = true;
                processTurn();
            } else {
                updateBattleLog(`Esperando a que el ${waitingForTeam1 ? 'Equipo 1' : 'Equipo 2'} seleccione una acción`);
            }
        }

        async function processTurn() {
            // Resetear las variables de selección de acción
            actionSelected1 = false;
            actionSelected2 = false;
            waitingForTeam1 = true;
            waitingForTeam2 = true;

            updateBattleDisplay();

            // Determinar el orden de ataque basado en la velocidad
            const firstAttacker = activePokemon1.speed >= activePokemon2.speed ? 
                { pokemon: activePokemon1, move: selectedMove1, team: 'team1' } : 
                { pokemon: activePokemon2, move: selectedMove2, team: 'team2' };
            
            const secondAttacker = firstAttacker.team === 'team1' ? 
                { pokemon: activePokemon2, move: selectedMove2, team: 'team2' } : 
                { pokemon: activePokemon1, move: selectedMove1, team: 'team1' };

            // Esperar un momento antes de comenzar el turno
            await new Promise(resolve => setTimeout(resolve, 500));

            // Procesar cambios de Pokémon primero
            if (lastAction1 === 'switch') {
                const result = await api.switchPokemon(currentBattleId, activePokemon1, true);
                if (result.error) {
                    updateBattleLog(result.error);
                    return;
                }
                if (result.message) {
                    updateBattleLog(result.message);
                    activePokemon1 = {...result.newActivePokemon, team: 'team1'};
                }
            }

            if (lastAction2 === 'switch') {
                const result = await api.switchPokemon(currentBattleId, activePokemon2, false);
                if (result.error) {
                    updateBattleLog(result.error);
                    return;
                }
                if (result.message) {
                    updateBattleLog(result.message);
                    activePokemon2 = {...result.newActivePokemon, team: 'team2'};
                }
            }

            // Actualizar la pantalla después de los cambios
            updateBattleDisplay();

            // Realizar el primer ataque si hay un movimiento seleccionado
            if (firstAttacker.move) {
                await performAttack(firstAttacker, secondAttacker.pokemon);
            }
            
            // Verificar si el segundo Pokémon ha sido derrotado
            if (secondAttacker.pokemon.health <= 0) {
                updateBattleLog(`${secondAttacker.pokemon.name} ha sido derrotado!`);
                if (checkBattleEnd()) {
                    turnInProgress = false;
                    selectedMove1 = null;
                    selectedMove2 = null;
                    lastAction1 = null;
                    lastAction2 = null;
                    updateBattleDisplay();
                    return;
                }
                
                updateBattleLog(`¡${secondAttacker.team === 'team1' ? 'Equipo 1' : 'Equipo 2'} debe seleccionar un nuevo Pokémon!`);
                // Deshabilitar la selección de movimientos hasta que se seleccione un nuevo Pokémon
                if (secondAttacker.team === 'team1') {
                    activePokemon1 = null;
                    lastAction1 = null;
                    waitingForTeam1 = true;
                    selectedMove1 = null;
                } else {
                    activePokemon2 = null;
                    lastAction2 = null;
                    waitingForTeam2 = true;
                    selectedMove2 = null;
                }
                updateBattleDisplay();
                
                // Si el segundo Pokémon fue derrotado, no realizar su ataque
                secondAttacker.move = null;
            }
            
            // Realizar el segundo ataque solo si el Pokémon no ha sido derrotado y tiene un movimiento seleccionado
            if (secondAttacker.move && secondAttacker.pokemon.health > 0) {
                await performAttack(secondAttacker, firstAttacker.pokemon);
            }

            // Verificar si el primer Pokémon ha sido derrotado
            if (firstAttacker.pokemon.health <= 0) {
                updateBattleLog(`${firstAttacker.pokemon.name} ha sido derrotado!`);
                if (checkBattleEnd()) {
                    turnInProgress = false;
                    selectedMove1 = null;
                    selectedMove2 = null;
                    lastAction1 = null;
                    lastAction2 = null;
                    updateBattleDisplay();
                    return;
                }
                
                updateBattleLog(`¡${firstAttacker.team === 'team1' ? 'Equipo 1' : 'Equipo 2'} debe seleccionar un nuevo Pokémon!`);
                // Deshabilitar la selección de movimientos hasta que se seleccione un nuevo Pokémon
                if (firstAttacker.team === 'team1') {
                    activePokemon1 = null;
                    lastAction1 = null;
                    waitingForTeam1 = true;
                    selectedMove1 = null;
                } else {
                    activePokemon2 = null;
                    lastAction2 = null;
                    waitingForTeam2 = true;
                    selectedMove2 = null;
                }
                updateBattleDisplay();
            }

            // Resetear los movimientos seleccionados y el estado del turno
            selectedMove1 = null;
            selectedMove2 = null;
            turnInProgress = false;
            lastAction1 = null;
            lastAction2 = null;
            updateBattleDisplay();

            // Incrementar el contador de turnos y mostrar el mensaje para el siguiente turno
            currentTurn++;
            updateBattleLog(`=== Turno ${currentTurn} ===`);

            // Habilitar la selección de acciones para ambos equipos
            setMoveAndSwitchButtonsEnabled(true, 'team1');
            setMoveAndSwitchButtonsEnabled(true, 'team2');
        }

        async function performAttack(attacker, defender) {
            try {
                // Asegurarnos de que el Pokémon atacante tenga el equipo correcto
                attacker.pokemon.team = attacker.team;
                
                // Verificar que el movimiento existe
                if (!attacker.move) {
                    console.error('No hay movimiento seleccionado para el atacante:', attacker);
                    updateBattleLog('Error: No hay movimiento seleccionado');
                    return;
                }

                // Animar el ataque
                await animateAttack(attacker.pokemon, defender);

                // Calcular la efectividad del ataque
                const effectiveness = await api.calculateTypeEffectiveness({
                    attackType: attacker.move.type,
                    defenderTypes: defender.types
                });

                // Calcular el daño
                const damage = calculateDamage(attacker.pokemon, defender, attacker.move, effectiveness);

                // Aplicar el daño
                defender.health = Math.max(0, defender.health - damage);

                // Actualizar la vida del Pokémon en el equipo
                const defenderTeam = defender.team === 'team1' ? selectedTeam1 : selectedTeam2;
                const defenderInTeam = defenderTeam.find(p => p.uniqueId === defender.uniqueId);
                if (defenderInTeam) {
                    defenderInTeam.health = defender.health;
                }

                // Mostrar mensaje de ataque
                let message = `${attacker.pokemon.name} ha usado ${attacker.move.name} y ha infligido ${damage} de daño a ${defender.name}`;
                
                // Añadir mensaje de efectividad
                if (effectiveness > 1) {
                    message += '\n¡Es super efectivo!';
                } else if (effectiveness < 1) {
                    message += '\nNo es muy efectivo...';
                }

                updateBattleLog(message);
                updateBattleDisplay();

            } catch (error) {
                console.error('Error al realizar el ataque:', error);
                updateBattleLog('Error al realizar el ataque');
            }
        }

        function calculateDamage(attacker, defender, move, effectiveness) {
            // Fórmula simplificada de daño base
            const attack = move.category === 'physical' ? attacker.attack : attacker.specialAttack;
            const defense = move.category === 'physical' ? defender.defense : defender.specialDefense;
            
            let damage = ((2 * 50 / 5 + 2) * move.power * (attack / defense)) / 50 + 2;
            
            // Aplicar variación aleatoria (85-100%)
            damage *= (0.85 + Math.random() * 0.15);
            
            // Aplicar la efectividad de tipos
            damage *= effectiveness;
            
            return Math.floor(damage);
        }

        // Cambiar Pokémon
        async function switchPokemon(pokemon, teamId) {
            if (turnInProgress || battleOver) return;

            // Resetear el bloqueo de movimientos al cambiar de Pokémon
            if (teamId === 'team1') {
                lockedMoveTeam1 = null;
            } else {
                lockedMoveTeam2 = null;
            }

            // Si no hay batalla activa, simplemente actualizamos el Pokémon activo
            if (!currentBattleId) {
                if (teamId === 'team1') {
                    activePokemon1 = pokemon;
                } else {
                    activePokemon2 = pokemon;
                }
                updateBattleDisplay();
                updateBattleLog(`${pokemon.name} ha entrado en combate`);
                return;
            }

            const selectedMove = teamId === 'team1' ? selectedMove1 : selectedMove2;
            const lastAction = teamId === 'team1' ? lastAction1 : lastAction2;
            const activePokemon = teamId === 'team1' ? activePokemon1 : activePokemon2;
            const isForcedSwitch = !activePokemon || activePokemon.health <= 0;

            if (!isForcedSwitch) {
                if (selectedMove || lastAction === 'move') {
                    updateBattleLog(`El ${teamId === 'team1' ? 'Equipo 1' : 'Equipo 2'} ya ha seleccionado un movimiento en este turno`);
                    return;
                }
                if (selectedMove || lastAction === 'switch') {
                    updateBattleLog(`El ${teamId === 'team1' ? 'Equipo 1' : 'Equipo 2'} ya ha seleccionado un cambio de Pokémon en este turno`);
                    return;
                }
            }

            // Si el cambio es forzado, no mostrar botón de cancelar y actualizar directamente
            if (isForcedSwitch) {
                if (teamId === 'team1') {
                    activePokemon1 = pokemon;
                    waitingForTeam1 = false;
                    waitingForTeam2 = false;
                    selectedMove1 = null; // Resetear el movimiento seleccionado
                } else {
                    activePokemon2 = pokemon;
                    waitingForTeam2 = false;
                    waitingForTeam1 = false;
                    selectedMove2 = null; // Resetear el movimiento seleccionado
                }
                updateBattleDisplay();
                updateBattleLog(`${pokemon.name} ha entrado en combate`);
                // Si ambos equipos ya tienen Pokémon activos, continuar el combate
                if (!waitingForTeam1 && !waitingForTeam2) {
                    turnInProgress = true;
                    await processTurn();
                }
                return;
            }

            // Guardar el Pokémon activo actual antes de hacer el cambio
            const originalPokemon = teamId === 'team1' ? activePokemon1 : activePokemon2;

            // Cambio voluntario: mostrar botón de cancelar
            setMoveAndSwitchButtonsEnabled(false, teamId);
            const movesContainer = document.getElementById(`${teamId}Moves`);
            
            // Limpiar el contenedor de movimientos antes de añadir el nuevo botón de cancelar
            movesContainer.innerHTML = '';
            
            const cancelButton = document.createElement('button');
            cancelButton.className = 'cancel-button';
            cancelButton.textContent = 'Cancelar cambio';
            cancelButton.onclick = () => {
                if (teamId === 'team1') {
                    // Restaurar el Pokémon activo original
                    activePokemon1 = originalPokemon;
                    lastAction1 = null;
                    waitingForTeam1 = true;
                    selectedMove1 = null; // Resetear el movimiento seleccionado
                } else {
                    // Restaurar el Pokémon activo original
                    activePokemon2 = originalPokemon;
                    lastAction2 = null;
                    waitingForTeam2 = true;
                    selectedMove2 = null; // Resetear el movimiento seleccionado
                }
                setMoveAndSwitchButtonsEnabled(true, teamId);
                movesContainer.innerHTML = ''; // Limpiar el contenedor de movimientos
                updateBattleDisplay(); // Actualizar la visualización
            };
            movesContainer.appendChild(cancelButton);

            // Actualizar el Pokémon activo temporalmente para mostrar el cambio
            if (teamId === 'team1') {
                activePokemon1 = pokemon;
                lastAction1 = 'switch';
                waitingForTeam1 = false;
                selectedMove1 = null; // Resetear el movimiento seleccionado
            } else {
                activePokemon2 = pokemon;
                lastAction2 = 'switch';
                waitingForTeam2 = false;
                selectedMove2 = null; // Resetear el movimiento seleccionado
            }

            updateBattleLog(`${pokemon.name} ha entrado en combate al final`);

            if (!waitingForTeam1 && !waitingForTeam2) {
                turnInProgress = true;
                await processTurn();
            }
        }

        // Función para asegurar que la vida de los Pokémon esté al máximo al cargar equipos
        function setTeamHealthToMax(team) {
            if (Array.isArray(team)) {
                team.forEach(pokemon => {
                    // Siempre igualar la vida al máximo al cargar el equipo
                    pokemon.health = pokemon.maxHealth;
                });
            }
        }

        // Cargar equipos guardados
        function loadTeams() {
            const savedTeams = localStorage.getItem('pokemonTeams');
            console.log('LoadTeams - savedTeams from localStorage:', savedTeams);
            if (savedTeams) {
                try {
                    const teamsData = JSON.parse(savedTeams);
                    console.log('Equipos cargados (parsed):', teamsData);
                    
                    allTeams = {};
                    let uniqueCounter = 0; // Contador para uniqueId
                    for (const [teamName, teamHashes] of Object.entries(teamsData)) {
                        allTeams[teamName] = teamHashes.map((pokemonHash, idx) => {
                            console.log(`Buscando datos para Pokémon: ${pokemonHash}`);
                            const pokemonData = localStorage.getItem(pokemonHash);
                            if (!pokemonData) {
                                console.warn(`No se encontraron datos para el Pokémon ${pokemonHash}`);
                                return null;
                            }
                            try {
                                const parsedData = JSON.parse(pokemonData);
                                // Asignar un identificador único aunque sean iguales
                                parsedData.uniqueId = `${parsedData.id}_${teamName}_${idx}_${Date.now()}_${uniqueCounter++}`;
                                
                                // Asegurar que los objetos tengan sus efectos extra
                                if (parsedData.heldItem && parsedData.heldItem.id) {
                                    // Cargar los efectos extra del objeto desde la base de datos
                                    // Esto se hará cuando se carguen los objetos en el frontend
                                    console.log('Pokémon con objeto:', parsedData.name, 'Objeto:', parsedData.heldItem.name);
                                }
                                
                                return parsedData;
                            } catch (e) {
                                console.error(`Error al parsear datos del Pokémon ${pokemonHash}:`, e);
                                return null;
                            }
                        }).filter(pokemon => pokemon !== null);
                    }
                    
                    console.log('Equipos procesados (allTeams):', allTeams);
                    
                    // Verificar que los equipos tengan datos válidos
                    for (const [teamName, team] of Object.entries(allTeams)) {
                        if (!Array.isArray(team) || team.length === 0) {
                            console.error(`El equipo ${teamName} no tiene Pokémon válidos`);
                            delete allTeams[teamName];
                        }
                    }
                    
                    if (Object.keys(allTeams).length === 0) {
                        throw new Error('No se encontraron equipos válidos');
                    }
                    
                    // Cargar efectos extra de objetos después de cargar los equipos
                    loadItemEffects();
                    
                    updateTeamSelectors();

                } catch (error) {
                    console.error('Error al cargar equipos:', error);
                    alert('Error al cargar los equipos: ' + error.message);
                }
            } else {
                console.log('No hay equipos guardados');
                alert('No hay equipos guardados. Por favor, crea equipos en la página de Pokédex.');
                window.location.href = 'pokemon.html';
            }
        }
        
        // Función para cargar efectos extra de objetos
        async function loadItemEffects() {
            try {
                const response = await fetch('/api/pokemon/items');
                if (response.ok) {
                    const items = await response.json();
                    
                    // Actualizar efectos extra en todos los Pokémon de todos los equipos
                    for (const [teamName, team] of Object.entries(allTeams)) {
                        team.forEach(pokemon => {
                            if (pokemon.heldItem && pokemon.heldItem.id) {
                                const itemData = items[pokemon.heldItem.id];
                                if (itemData && itemData.extraEffects) {
                                    pokemon.heldItem.extraEffects = itemData.extraEffects;
                                    console.log(`Efectos extra cargados para ${pokemon.name}:`, itemData.extraEffects);
                                }
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error al cargar efectos de objetos:', error);
            }
        }

        // Actualizar selectores de equipos
        function updateTeamSelectors() {
            const team1Selector = document.getElementById('team1Selector');
            const team2Selector = document.getElementById('team2Selector');
            
            team1Selector.innerHTML = '<option value="">Selecciona Equipo 1</option>';
            team2Selector.innerHTML = '<option value="">Selecciona Equipo 2</option>';
            
            for (const teamName in allTeams) {
                const teamData = allTeams[teamName];
                if (Array.isArray(teamData) && teamData.length > 0) {
                    team1Selector.innerHTML += `<option value="${teamName}">${teamName}</option>`;
                    team2Selector.innerHTML += `<option value="${teamName}">${teamName}</option>`;
                }
            }

            // Agregar event listeners para los cambios en los selectores
            team1Selector.addEventListener('change', function() {
                selectedTeam1 = this.value ? allTeams[this.value] : null;
                if (selectedTeam1 && selectedTeam1.length > 0) {
                    // Asegurar que la vida esté al máximo al seleccionar el equipo
                    setTeamHealthToMax(selectedTeam1);
                    // No seleccionar automáticamente, mostrar opciones
                    activePokemon1 = null;
                    console.log('Equipo 1 seleccionado:', selectedTeam1);
                    updateTeamPokemon('team1', selectedTeam1);
                }
                updateBattleDisplay();
            });

            team2Selector.addEventListener('change', function() {
                selectedTeam2 = this.value ? allTeams[this.value] : null;
                if (selectedTeam2 && selectedTeam2.length > 0) {
                    // Asegurar que la vida esté al máximo al seleccionar el equipo
                    setTeamHealthToMax(selectedTeam2);
                    // No seleccionar automáticamente, mostrar opciones
                    activePokemon2 = null;
                    console.log('Equipo 2 seleccionado:', selectedTeam2);
                    updateTeamPokemon('team2', selectedTeam2);
                }
                updateBattleDisplay();
            });

            // No seleccionar equipos por defecto
            updateBattleDisplay();
        }

        // --- Funciones adicionales ---

        function updateBattleDisplay() {
            // Actualizar lista de Pokémon de cada equipo
            if (selectedTeam1) {
                // Asegurarnos de que el Pokémon activo tenga la misma referencia que en el equipo
                if (activePokemon1) {
                    const pokemonInTeam = selectedTeam1.find(p => p.uniqueId === activePokemon1.uniqueId);
                    if (pokemonInTeam) {
                        activePokemon1 = pokemonInTeam;
                    }
                }
                updateTeamPokemon('team1', selectedTeam1);
            } else {
                document.getElementById('team1Pokemon').innerHTML = '';
            }

            if (selectedTeam2) {
                // Asegurarnos de que el Pokémon activo tenga la misma referencia que en el equipo
                if (activePokemon2) {
                    const pokemonInTeam = selectedTeam2.find(p => p.uniqueId === activePokemon2.uniqueId);
                    if (pokemonInTeam) {
                        activePokemon2 = pokemonInTeam;
                    }
                }
                updateTeamPokemon('team2', selectedTeam2);
            } else {
                document.getElementById('team2Pokemon').innerHTML = '';
            }

            // Actualizar Pokémon activo del Equipo 1
            if (activePokemon1) {
                document.getElementById('team1ActivePokemon').src = activePokemon1.imageUrl;
                document.getElementById('team1PokemonName').textContent = `${activePokemon1.name} Lv.${activePokemon1.level || 50}`;
                const healthPercentage1 = (activePokemon1.health / activePokemon1.maxHealth) * 100;
                document.getElementById('team1HealthBar').style.width = `${healthPercentage1}%`;
                document.getElementById('team1Health').textContent = `HP: ${activePokemon1.health}/${activePokemon1.maxHealth}`;
                updateMoves('team1', activePokemon1);
                
                // Mostrar información de configuración
                const nature1 = activePokemon1.nature ? activePokemon1.nature.name : 'Aleatoria';
                const heldItem1 = activePokemon1.heldItem ? activePokemon1.heldItem.name : 'Ninguno';
                const selectedAbility1 = activePokemon1.selectedAbility ? activePokemon1.selectedAbility.name : 'Ninguna';
                
                // Actualizar tooltip o información adicional
                const team1Section = document.querySelector('.team-section:first-child');
                let configInfo = team1Section.querySelector('.config-info');
                if (!configInfo) {
                    configInfo = document.createElement('div');
                    configInfo.className = 'config-info';
                    configInfo.style.cssText = 'font-size: 12px; margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.05); border-radius: 5px;';
                    team1Section.appendChild(configInfo);
                }
                configInfo.innerHTML = `
                    <div><strong>Naturaleza:</strong> ${nature1}</div>
                    <div><strong>Objeto:</strong> ${heldItem1}</div>
                    <div><strong>Habilidad:</strong> ${selectedAbility1}</div>
                `;
            } else {
                document.getElementById('team1ActivePokemon').src = '';
                document.getElementById('team1PokemonName').textContent = 'Selecciona un Pokémon';
                document.getElementById('team1Health').textContent = '';
                document.getElementById('team1HealthBar').style.width = '0%';
                document.getElementById('team1Moves').innerHTML = '';
                
                // Limpiar información de configuración
                const team1Section = document.querySelector('.team-section:first-child');
                const configInfo = team1Section.querySelector('.config-info');
                if (configInfo) configInfo.remove();
            }

            // Actualizar Pokémon activo del Equipo 2
            if (activePokemon2) {
                document.getElementById('team2ActivePokemon').src = activePokemon2.imageUrl;
                document.getElementById('team2PokemonName').textContent = `${activePokemon2.name} Lv.${activePokemon2.level || 50}`;
                const healthPercentage2 = (activePokemon2.health / activePokemon2.maxHealth) * 100;
                document.getElementById('team2HealthBar').style.width = `${healthPercentage2}%`;
                document.getElementById('team2Health').textContent = `HP: ${activePokemon2.health}/${activePokemon2.maxHealth}`;
                updateMoves('team2', activePokemon2);
                
                // Mostrar información de configuración
                const nature2 = activePokemon2.nature ? activePokemon2.nature.name : 'Aleatoria';
                const heldItem2 = activePokemon2.heldItem ? activePokemon2.heldItem.name : 'Ninguno';
                const selectedAbility2 = activePokemon2.selectedAbility ? activePokemon2.selectedAbility.name : 'Ninguna';
                
                // Actualizar tooltip o información adicional
                const team2Section = document.querySelector('.team-section:nth-child(2)');
                let configInfo = team2Section.querySelector('.config-info');
                if (!configInfo) {
                    configInfo = document.createElement('div');
                    configInfo.className = 'config-info';
                    configInfo.style.cssText = 'font-size: 12px; margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.05); border-radius: 5px;';
                    team2Section.appendChild(configInfo);
                }
                configInfo.innerHTML = `
                    <div><strong>Naturaleza:</strong> ${nature2}</div>
                    <div><strong>Objeto:</strong> ${heldItem2}</div>
                    <div><strong>Habilidad:</strong> ${selectedAbility2}</div>
                `;
            } else {
                document.getElementById('team2ActivePokemon').src = '';
                document.getElementById('team2PokemonName').textContent = 'Selecciona un Pokémon';
                document.getElementById('team2Health').textContent = '';
                document.getElementById('team2HealthBar').style.width = '0%';
                document.getElementById('team2Moves').innerHTML = '';
                
                // Limpiar información de configuración
                const team2Section = document.querySelector('.team-section:nth-child(2)');
                const configInfo = team2Section.querySelector('.config-info');
                if (configInfo) configInfo.remove();
            }

            // Habilitar/deshabilitar botones según el estado de la batalla
            // Después del reset, permitir la selección de Pokémon si no hay batalla activa
            const shouldEnableButtons = !battleOver && !turnInProgress && 
                (!currentBattleId || (activePokemon1 && activePokemon2));
            setMoveAndSwitchButtonsEnabled(shouldEnableButtons);
        }

        function startBattle() {
            console.log('Intentando iniciar batalla:');
            console.log('selectedTeam1:', selectedTeam1);
            console.log('selectedTeam2:', selectedTeam2);
            console.log('activePokemon1:', activePokemon1);
            console.log('activePokemon2:', activePokemon2);

            if (!selectedTeam1 || !selectedTeam2) {
                updateBattleLog('Por favor, selecciona ambos equipos antes de iniciar la batalla');
                return;
            }

            if (!activePokemon1 || !activePokemon2) {
                // Intentar seleccionar automáticamente los primeros Pokémon si no están seleccionados
                if (!activePokemon1 && selectedTeam1.length > 0) {
                    activePokemon1 = selectedTeam1[0];
                }
                if (!activePokemon2 && selectedTeam2.length > 0) {
                    activePokemon2 = selectedTeam2[0];
                }
                
                // Verificar nuevamente después de intentar la selección automática
                if (!activePokemon1 || !activePokemon2) {
                    updateBattleLog('Por favor, selecciona los Pokémon iniciales para ambos equipos');
                    return;
                }
            }

            // Asegurarse de que las variables de estado estén correctamente configuradas
            waitingForTeam1 = true;
            waitingForTeam2 = true;
            turnInProgress = false;
            battleOver = false;
            selectedMove1 = null;
            selectedMove2 = null;
            lastAction1 = null;
            lastAction2 = null;
            actionSelected1 = false;
            actionSelected2 = false;

            // Incrementar el contador de turnos y mostrar el mensaje
            currentTurn++;
            updateBattleLog(`=== Turno ${currentTurn} ===`);

            // Iniciar la batalla en el backend
            api.startBattle(selectedTeam1, selectedTeam2)
                .then(result => {
                    if (result.error) {
                        updateBattleLog(result.error);
                        return;
                    }

                    currentBattleId = result.battleId;
                    turnInProgress = false;
                    battleOver = false;
                    initialSelectionPending = false;
                    updateBattleDisplay();
                    updateBattleLog('¡La batalla ha comenzado!');
                })
                .catch(error => {
                    console.error('Error al iniciar la batalla:', error);
                    updateBattleLog(`Error al iniciar la batalla: ${error.message}`);
                });
        }

        function resetBattle() {
            // Resetear variables de batalla
            currentBattleId = null; // Resetear el ID de la batalla
            battleOver = false;
            selectedMove1 = null;
            selectedMove2 = null;
            activePokemon1 = null;
            activePokemon2 = null;
            turnInProgress = false;
            actionSelected1 = false;  // Resetear la selección de acción del equipo 1
            actionSelected2 = false;  // Resetear la selección de acción del equipo 2
            currentTurn = 0; // Resetear el contador de turnos
            lastAction1 = null; // Resetear la última acción del equipo 1
            lastAction2 = null; // Resetear la última acción del equipo 2
            waitingForTeam1 = true; // Resetear el estado de espera del equipo 1
            waitingForTeam2 = true; // Resetear el estado de espera del equipo 2
            initialSelectionPending = true; // Resetear la bandera de selección inicial
            
            // Resetear bloqueos de movimientos Choice
            lockedMoveTeam1 = null;
            lockedMoveTeam2 = null;

            // Regenerar HP de todos los Pokémon en ambos equipos
            if (selectedTeam1) {
                selectedTeam1.forEach(pokemon => {
                    pokemon.health = pokemon.maxHealth;
                });
            }
            if (selectedTeam2) {
                selectedTeam2.forEach(pokemon => {
                    pokemon.health = pokemon.maxHealth;
                });
            }

            // Limpiar completamente el registro de batalla
            battleLog = []; // Resetear el array de battleLog
            const battleLogElement = document.getElementById('battleLog');
            battleLogElement.innerHTML = ''; // Limpiar el contenido HTML
            updateBattleLog('¡La batalla ha comenzado!');

            // Actualizar la interfaz
            updateBattleDisplay();
        }

        async function animateAttack(source, target) {
            return new Promise((resolve) => {
                // Buscar los elementos de los Pokémon en la arena de batalla
                const sourceElement = document.querySelector(`.pokemon-card[data-pokemon-id="${source.uniqueId}"].active`);
                const targetElement = document.querySelector(`.pokemon-card[data-pokemon-id="${target.uniqueId}"].active`);

                if (!sourceElement || !targetElement) {
                    console.warn('No se encontraron elementos para animar:', { source, target });
                    resolve();
                    return;
                }

                // Determinar qué movimiento mostrar basado en el equipo del Pokémon atacante
                let moveToShow;
                if (source.team === 'team1') {
                    moveToShow = selectedMove1;
                } else if (source.team === 'team2') {
                    moveToShow = selectedMove2;
                }

                if (!moveToShow) {
                    console.warn('No se encontró el movimiento para mostrar:', { source, target });
                    resolve();
                    return;
                }

                // Crear el texto del movimiento
                const moveText = document.createElement('div');
                moveText.className = 'move-text';
                moveText.textContent = `${source.name} usa ${moveToShow.name}!`;
                document.querySelector('.battle-arena').appendChild(moveText);

                // Aplicar la animación de ataque
                sourceElement.classList.add('attacking');
                targetElement.classList.add('taking-damage');

                // Limpiar las animaciones después de que terminen
                setTimeout(() => {
                    sourceElement.classList.remove('attacking');
                    targetElement.classList.remove('taking-damage');
                    moveText.remove();
                    resolve();
                }, ATTACK_ANIMATION_DURATION);
            });
        }

        // Función para verificar si un equipo está derrotado
        function isTeamDefeated(team) {
            return team.every(pokemon => pokemon.health <= 0);
        }

        // Función para verificar si la batalla ha terminado
        function checkBattleEnd() {
            if (!selectedTeam1 || !selectedTeam2) return false;
            
            const team1Defeated = isTeamDefeated(selectedTeam1);
            const team2Defeated = isTeamDefeated(selectedTeam2);
            
            if (team1Defeated || team2Defeated) {
                battleOver = true;
                const winner = team1Defeated ? 'Equipo 2' : 'Equipo 1';
                updateBattleLog(`¡La batalla ha terminado! ${winner} ha ganado.`);
                
                // Mostrar animación del ganador
                showWinnerAnimation(winner);
                return true;
            }
            return false;
        }

        // Función para mostrar la animación del ganador
        function showWinnerAnimation(winner) {
            const announcement = document.getElementById('winnerAnnouncement');
            const winnerText = document.getElementById('winnerText');
            winnerText.textContent = `${winner} ha ganado la batalla!`;
            
            // Mostrar el anuncio
            announcement.classList.add('show');
            
            // Crear confeti
            createConfetti();
            
            // Ocultar el anuncio después de 5 segundos
            setTimeout(() => {
                announcement.classList.remove('show');
            }, 5000);
        }

        // Función para crear el efecto de confeti
        function createConfetti() {
            const colors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
            const container = document.querySelector('.container');
            
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animation = `confetti-fall ${Math.random() * 3 + 2}s linear forwards`;
                container.appendChild(confetti);
                
                // Eliminar el confeti después de la animación
                setTimeout(() => {
                    confetti.remove();
                }, 5000);
            }
        }

        // Actualizar registro de batalla
        function updateBattleLog(message) {
            battleLog.push(message);
            const battleLogElement = document.getElementById('battleLog');
            battleLogElement.innerHTML = battleLog.map(msg => `<p>${msg}</p>`).join('');
            battleLogElement.scrollTop = battleLogElement.scrollHeight;
        }

        // Función para alternar el modo oscuro
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
        }

        // Cargar preferencia de tema al iniciar
        document.addEventListener('DOMContentLoaded', () => {
            if (localStorage.getItem('darkMode') === 'true') {
                document.body.classList.add('dark-mode');
            }
            loadTeams();
        });
    </script>
</body>
</html>
